# Backend Routes & Database Schema

This document describes the backend HTTP routes and the database schema (collections) used for payment processing, user subscriptions, and related operations.

Place this file in `server/` — it documents the endpoints implemented (or scaffolded) in `server/routes/` and how the frontend should call them.

---

## Environment variables

Add these to your server `.env` (never commit to source control):

```
# Flutterwave
FLUTTERWAVE_SECRET_KEY=FLWSECK-xxxxxxxxxxxxxxxxxxxxxxxx
FLUTTERWAVE_ENCRYPTION_KEY=xxxxxxxxxxxxxxxxxxxxxxxx

# Optional public key (for convenience, used by frontend build-time env)
VITE_FLUTTERWAVE_PUBLIC_KEY=FLWPUBK-xxxxxxxxxxxxxxxxxxxx

# App settings
PORT=8080

# MongoDB (used by server persistence)
MONGO_URL=mongodb://localhost:27017
MONGO_DB=script_app

```

---

## Routes (HTTP)

All routes below are relative to your API base (for example, `/api/*`).

### POST /api/payments/initialize
Purpose: Create a payment session before opening the Flutterwave modal. The frontend now sends a `signup` payload (containing the user's signup info) and the server persists a pending payment record in MongoDB and returns a `tx_ref`, amount (in Naira), and customer details.

Request body (preferred):

```json
{
  "signup": {
    "name": "Business Name",
    "email": "owner@example.com",
    "phone": "08012345678",
    "password": "s3cret",
    "businessName": "Acme Co",
    "businessType": "product_seller",
    "plan": "standard"
  }
}
```

Response (200):

```json
{
  "status": "success",
  "tx_ref": "tx-<timestamp>-<random>",
  "amount": 500,            // amount in Naira (₦500)
  "currency": "NGN",
  "customer": { "email": "...", "phone_number": "...", "name": "..." },
  "planDetails": { "name": "standard", "amount": 500 }
}
```

Notes:
- The server persists a `payments` document in MongoDB with `status: "pending"` and stores the original `signup` payload (for later account creation on successful verification).
- Amounts returned to the client are in Naira (e.g., 500), which matches what the Flutterwave checkout expects. Internally the server may store amounts in cents/kobo for accuracy.
- `tx_ref` is generated by the server (e.g., `tx-<timestamp>-<rand>`) and must be unique.

---

### POST /api/payments/verify
Purpose: After the client receives a transaction id from Flutterwave, POST here to verify the payment server-side using the Secret Key and finalize the signup (create the user) if verification succeeds.

Request body (two supported forms):

1) Minimal (if user already exists / userId known):

```json
{
  "id": "<flutterwave-transaction-id>",
  "tx_ref": "<tx_ref-from-init>",
  "userId": "<user-id>",
  "plan": "standard",
  "amount": 500
}
```

2) With signup payload (recommended for account creation after payment):

```json
{
  "id": "<flutterwave-transaction-id>",
  "tx_ref": "<tx_ref-from-init>",
  "signup": { /* same shape as initialize.signup */ },
  "amount": 500
}
```

Notes about `amount`:
- `amount` sent in the verify request should be in Naira (e.g., 500) — the server verifies the Flutterwave response's `amount` against this value.

Response (200 success):

```json
{
  "status": "success",
  "message": "Payment verified and subscription activated",
  "data": {
    "userId": "...",
    "plan": "standard",
    "subscriptionStatus": "active",
    "subscriptionStartDate": "2025-11-11T...",
    "subscriptionEndDate": "2025-12-11T...",
    "transactionId": "<id>",
    "txRef": "<tx_ref>",
    "amount": 500
  }
}
```

Failure responses should return appropriate 4xx/5xx codes and clear messages.

Important server responsibilities:
- Verify the transaction via Flutterwave verify endpoint using `FLUTTERWAVE_SECRET_KEY`.
- Validate `verification.status === 'success'` and `verification.data.status === 'successful'`.
- Validate `verification.data.tx_ref === tx_ref` and `verification.data.amount === expectedAmount` (amount in Naira).
- Create the user account (hash the password) if a `signup` payload is provided and mark subscription as active.
- Update the `payments` document with status `successful`, the `transactionId`, `verifiedAt`, and link the payment to the created user.
- Ensure idempotency: if the `payments` doc already shows `status: 'successful'`, return success without duplicating user creation.

---

### POST /api/payments/webhook
Purpose: (Optional but recommended) Flutterwave webhook receiver. Flutterwave will POST events here (e.g., `charge.completed`).

Notes:
- Verify the webhook signature using `FLUTTERWAVE_ENCRYPTION_KEY` (check `verif-hash` header and compare to HMAC/SHA256 of the payload).
- Use the webhook as a backup to mark payments as successful if the client verification is missed.

---

## MongoDB Collections (suggested)

This project uses MongoDB for persistence. Recommended collections and indexes:

- `users` collection
  - Fields: { name, email, phone, businessName, businessType, passwordHash, plan, subscriptionStatus, subscriptionStartDate, subscriptionEndDate, createdAt }
  - Indexes: { email: 1 } (unique)

- `payments` collection
  - Fields: { tx_ref, transactionId, plan, amount_cents, amount_display, currency, status, customer, signupPayload, userId, flutterwaveResponse, createdAt, verifiedAt }
  - Indexes: { tx_ref: 1 } (unique), { transactionId: 1 }

Index examples (run once against your DB):

```js
db.users.createIndex({ email: 1 }, { unique: true });
db.payments.createIndex({ tx_ref: 1 }, { unique: true });
db.payments.createIndex({ transactionId: 1 });
```

---

## Example server-side verification flow (summary)

1. Receive `id` and `tx_ref` from client.
2. Call Flutterwave verify endpoint:

```js
GET https://api.flutterwave.com/v3/transactions/:id/verify
Headers: { Authorization: `Bearer ${FLUTTERWAVE_SECRET_KEY}` }
```

3. Validate:
- verification.status === 'success'
- verification.data.status === 'successful'
- verification.data.tx_ref === tx_ref
- verification.data.amount === expectedAmount (in naira)

4. Mark payment document as `successful`, create the user (if signup payload provided) and update `payments` and `users` collections.

5. Return success to client.

---

## Sample cURL commands

Initialize payment (create tx_ref):

```bash
curl -X POST https://your-domain.com/api/payments/initialize \
  -H "Content-Type: application/json" \
  -d '{"signup": {"name":"A User","email":"a@b.com","phone":"0801","password":"s3cret","businessName":"Acme","plan":"standard"}}'
```

Verify payment (with signup payload):

```bash
curl -X POST https://your-domain.com/api/payments/verify \
  -H "Content-Type: application/json" \
  -d '{"id":"<transaction_id>","tx_ref":"tx-...","signup": {"name":"A User","email":"a@b.com","password":"s3cret","plan":"standard"},"amount":500}'
```

---

## Recommended middleware & security

- Use HTTPS (TLS) in production.
- Verify webhook signatures using `FLUTTERWAVE_ENCRYPTION_KEY`.
- Rate-limit payment endpoints.
- Log requests & responses (redact sensitive fields such as passwordHash).
- Keep `FLUTTERWAVE_SECRET_KEY`, `FLUTTERWAVE_ENCRYPTION_KEY`, and `MONGO_URL` in environment variables only.

---

## Dependencies to install on the server

- mongodb
- bcryptjs

Install with:

```bash
pnpm add mongodb bcryptjs
# or npm install mongodb bcryptjs
```

---

## Next Steps / To implement

1. Wire routes into `server/index.ts` or your Express app:

```js
import { initializePayment, verifyPayment, paymentWebhook } from './routes/payments';

app.post('/api/payments/initialize', initializePayment);
app.post('/api/payments/verify', verifyPayment);
app.post('/api/payments/webhook', paymentWebhook);
```

2. Ensure MongoDB is reachable and add the environment variables `MONGO_URL` and `MONGO_DB`.
3. Optionally add index creation (see the examples above).
4. Test end-to-end in Flutterwave sandbox and then swap to production keys.

---

If you want, I can generate a short migration helper that creates the recommended indexes and wire the routes into `server/index.ts`. Which would you like next?
